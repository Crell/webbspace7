<?php

/**
 * Implements hook_field_schema().
 */
function entityreference_field_schema($field) {
  if ($field['type'] == 'entityreference') {
    $schema = array(
      'columns' => array(
        'target_id' => array(
          'description' => 'The id of the target entity',
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
        ),
      ),
      'indexes' => array(
        'target_id' => array('target_id'),
      ),
      'foreign keys' => array(),
    );

    // Create a foreign key to the target entity type base type, if available.
    $entity_type = $field['settings']['target_type'];
    $entity_info = _entityreference_entity_get_info($entity_type);
    if (isset($entity_info['base table'])) {
      $schema['foreign keys'][$entity_info['base table']] = array(
        'table' => $entity_info['base table'],
        'columns' => array('target_id' => $entity_info['entity keys']['id']),
      );
    }

    // Invoke the behaviors to allow them to change the schema.
    foreach (entityreference_get_behavior_handlers($field) as $handler) {
      $handler->schema_alter($schema, $field);
    }

    return $schema;
  }
}

/**
 * Replacement for entity_get_info() that is safe to call inside a hook_schema().
 *
 * The normal entity_get_info() indirectly calls drupal_get_schema() and as
 * a consequence is not safe from inside a hook_schema() or hook_field_schema().
 */
function _entityreference_entity_get_info($entity_type = NULL) {
  $entity_info = &drupal_static(__FUNCTION__);

  if (!isset($entity_info)) {
    $entity_info = module_invoke_all('entity_info');
    // Merge in default values.
    foreach ($entity_info as $name => $data) {
      $entity_info[$name] += array(
        'fieldable' => FALSE,
        'controller class' => 'DrupalDefaultEntityController',
        'static cache' => TRUE,
        'field cache' => TRUE,
        'load hook' => $name . '_load',
        'bundles' => array(),
        'view modes' => array(),
        'entity keys' => array(),
        'translation' => array(),
      );
      $entity_info[$name]['entity keys'] += array(
        'revision' => '',
        'bundle' => '',
      );
      foreach ($entity_info[$name]['view modes'] as $view_mode => $view_mode_info) {
        $entity_info[$name]['view modes'][$view_mode] += array(
          'custom settings' => FALSE,
        );
      }
      // If no bundle key is provided, assume a single bundle, named after
      // the entity type.
      if (empty($entity_info[$name]['entity keys']['bundle']) && empty($entity_info[$name]['bundles'])) {
        $entity_info[$name]['bundles'] = array($name => array('label' => $entity_info[$name]['label']));
      }
    }
    // Let other modules alter the entity info.
    drupal_alter('entity_info', $entity_info);
  }
  if (isset($entity_type)) {
    return isset($entity_info[$entity_type]) ? $entity_info[$entity_type] : NULL;
  }
  else {
    return $entity_info;
  }
}

/**
 * Update the field configuration to the new plugin structure.
 */
function entityreference_update_7000() {
  // Enable ctools.
  if (!module_enable(array('ctools'))) {
    throw new DrupalUpdateException('This version of Entity Reference requires ctools, but it could not be enabled.');
  }

  // Get the list of fields of type 'entityreference'.
  $fields = array();
  foreach (field_info_fields() as $field_name => $field) {
    // Update the field configuration.
    if ($field['type'] == 'entityreference') {
      $settings = &$field['settings'];
      if (!isset($settings['handler'])) {
        $settings['handler'] = 'base';
        $settings['handler_settings']['target_bundles'] = $settings['target_bundles'];
        unset($settings['target_bundles']);
        field_update_field($field);
      }
    }

    // Update the instance configurations.
    foreach ($field['bundles'] as $entity_type => $bundles) {
      foreach ($bundles as $bundle) {
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        $save = FALSE;
        if ($instance['widget']['type'] == 'entityreference_autocomplete') {
          $instance['widget']['type'] = 'entityreference_autocomplete_tags';
          $save = TRUE;
        }
        // When the autocomplete path is the default value, remove it from
        // the configuration.
        if (isset($instance['widget']['settings']['path']) && $instance['widget']['settings']['path'] == 'entityreference/autocomplete') {
          unset($instance['widget']['settings']['path']);
          $save = TRUE;
        }
        if ($save) {
          field_update_instance($instance);
        }
      }
    }
  }
}

/**
 * Drop "target_type" from the field schema.
 */
function entityreference_update_7001() {
  if (!module_exists('field_sql_storage')) {
    return;
  }
  foreach (field_info_fields() as $field_name => $field) {
    if ($field['type'] != 'entityreference') {
      // Not an entity reference field.
      continue;
    }
    if ($field['storage']['type'] !== 'field_sql_storage') {
      // Field doesn't use SQL storage.
      continue;
    }
    $table_name = _field_sql_storage_tablename($field);
    $revision_name = _field_sql_storage_revision_tablename($field);

    db_drop_field($table_name, $field_name . '_target_type');
    db_drop_index($table_name, $field_name . '_target_entity');
    db_add_index($table_name, $field_name . '_target_id', array($field_name . '_target_id'));

    db_drop_field($revision_name, $field_name . '_target_type');
    db_drop_index($revision_name, $field_name . '_target_entity');
    db_add_index($revision_name, $field_name . '_target_id', array($field_name . '_target_id'));

    // Update the field settings.
    $field = field_info_field($field_name);
    $field['indexes'] = array('target_id' => array('target_id'));
    field_update_field($field);
  }
}
